#!/bin/bash
# Wrapper script around git to perform
# action on multiple repository


set -Eeuo pipefail
source bashlib-echo.sh
source bashlib-error.sh
error::set_trap


# Git Directory to checkout may be in a config file
GITALL_CONF_FILE=${GITALL_CONF_FILE:-}
if [ "$GITALL_CONF_FILE" != "" ] && [ -f "$GITALL_CONF_FILE" ]; then
  IFS=$'\n' read -r -a REPO_DIRS -d $'\c0' <"$GITALL_CONF_FILE"
  echo::info"${#REPO_DIRS[*]} directory found in $GITALL_CONF_FILE"
fi


# The root directory where all repository may be the children
GITALL_CODE_HOME=${GITALL_CODE_HOME:-$HOME/code}
for childPath in "$GITALL_CODE_HOME"/*; do
  if [ -d "$childPath" ]; then
    REPO_DIRS+=("$childPath")
  fi
done

if [ ${#REPO_DIRS[*]} == 0 ]; then
  echo::err 'No Git repository found'
  exit 1
fi


for REPO_DIR in "${REPO_DIRS[@]}"; do
  pushd "$REPO_DIR" >/dev/null
  PWD=$(pwd)
  FQDN=${PWD##*/} # the directory name is the FQDN
  echo "* ${FQDN^} ($PWD)"
  CURRENT_BRANCH=$(git symbolic-ref HEAD --short)
  echo "  * Branch: $CURRENT_BRANCH"
  CURRENT_BRANCH_UPSTREAM=$(git rev-parse --abbrev-ref "@{u}")
  echo "  * Upstream: $CURRENT_BRANCH_UPSTREAM"
  COMMAND="git $@"
  if ! (eval "$COMMAND"); then
    echo::err "The command ${COMMAND} has error"
  fi
  echo ""
  popd >/dev/null
done

if [[ ${COMMAND} == 'status' ]]; then
  # As stated: https://git-scm.com/docs/git-ls-files#Documentation/git-ls-files.txt--t
  cat <<EOF
--------------------------------------------------------------
Legend File Status:
A - untracked new file (staged, in next commit)
H - tracked file that is not either unmerged or skip-worktree
S - tracked file that is skip-worktree
M - tracked file that is unmerged (may be or not staged, ie in the next commit)
R - tracked file with unstaged removal/deletion
C - tracked file with unstaged modification/change
K - untracked paths which are part of file/directory conflicts which prevent checking out tracked files
? - untracked file
U - file with resolve-undo information
EOF
fi

