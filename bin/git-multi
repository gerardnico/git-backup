#!/bin/bash
# Wrapper script around git to perform
# action on multiple repository

######################
# Standard Library and conf
######################
# The log and error handling
# We still need to use the set command
# because shellcheck does not see them and want use to add
# exit check everywhere
set -Eeuo pipefail
# echo and error_handling should be in your bashrc.d directory

# Load echo package
source bashlib-echo.sh


######################
# Main
######################

# Integrate the changes
# AutoPull to stay in the same fashion than AutoCommit
function gitAutoPull() {

  git fetch
  upstreamCommitToMerge=$(git rev-list HEAD...'@{u}' --count)

  echo "Integrating $upstreamCommitToMerge commits from $CURRENT_BRANCH_UPSTREAM into $CURRENT_BRANCH"
  if [ "$upstreamCommitToMerge" != 0 ]; then
    # Stash before a merge to integrate the remote changes
    # To avoid the error: Please commit your changes or stash them before you merge.
    #
    # Note that when the local changes do not conflict with the changes in the upstream,
    # a simple git pull let you move forward but how do we know that ?
    #
    git stash
    git merge '@{u}'
    git stash pop # do a merge
  fi

}

function gitStatus() {

  # Upstream
  git fetch
  upstreamCommitToMerge=$(git rev-list HEAD...'@{u}' --count)
  localCommitToPush=$(git rev-list '@{u}'...HEAD --count)
  echo "  * $upstreamCommitToMerge commits to merge"
  echo "  * $localCommitToPush commits to push"

  # for scripting: git status --porcelain
  # porcelain means give the output in an easy-to-parse format for scripts
  local vPorcelain
  vPorcelain=$(git status --porcelain)
  if [[ -z $vPorcelain ]]; then
    echo "No modifications"
  else
    # output:
    # for an unstaged file: `status space path`
    # for a staged file: `status space space path`
    echo "$vPorcelain" | while read -r fileStatusLine; do
      # fileStatus=${fileStatusLine:0:1} # not yet used
      fileStatusStaged=${fileStatusLine:1:2}
      if [ "${fileStatusStaged}" == '  ' ]; then
        inNextCommit=' (staged)'
        # filePath=${fileStatusLine:3} # not yet used
      else
        inNextCommit=' (unstaged)'
        # filePath=${fileStatusLine:2} # not yet used
      fi
      echo "$fileStatusLine$inNextCommit"
    done
  fi

}

# Cancel all modifications and start fresh
function gitResetAndClean() {
  git reset --hard
  git clean -f
}

# when there is nothing to commit, they say `working directory clean`
function gitAutoCommit() {

  if [[ -z $1 ]]; then
    echo::err"A message is mandatory for a commit"
    exit 1
  fi
  commitString="GIT_COMMITTER_NAME='beau.bytle.net' GIT_COMMITTER_EMAIL='support@combostrap.com' git commit --author 'Nico <nico@${FQDN}>' -m '$1'"
  eval "$commitString"

}


# ! [rejected]        master -> master (non-fast-forward)
#error: failed to push some refs to 'https://gerardnico:ghp_glKrr7@github.com/ComboStrap/website'
#hint: Updates were rejected because the tip of your current branch is behind
#hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
#hint: before pushing again.
#hint: See the 'Note about fast-forwards' in 'git push --help' for details.

function gitAutoPush() {

  # pull to avoid
  # `Updates were rejected because the tip of your current branch is behind`
  git pull

  # staged all changes
  git add -A

  # commit message
  declare -a files
  for path in $(git diff-index --name-only HEAD); do
    files+=(" ${path##*/}")
  done
  fileList=$(
    IFS=$', '
    echo "${files[*]}"
  )
  message="Update$fileList"
  echo "$message"

  # commit
  gitAutoCommit "$message"

  # push
  checkStatus
  git push

}


function gitStatusByFileType() {
  modified=$(git ls-files -m)
  if [[ -n $modified ]]; then
    echo "Modified not in commit: $modified"
  fi
  deleted=$(git ls-files -d)
  if [[ -n $deleted ]]; then
    echo "Deleted: $deleted"
  fi
  untracked=$(git ls-files -o)
  if [[ -n $untracked ]]; then
    echo "Untracked/Added: $untracked"
  fi
  if [[ -z $modified && -z $deleted && -z $untracked ]]; then
    echo "No modifications"
  fi
}

# Git Directory to checkout may be in a config file
GITALL_CONF_FILE=${GITALL_CONF_FILE:-}
if [ "$GITALL_CONF_FILE" != "" ] && [ -f "$GITALL_CONF_FILE" ]; then
  IFS=$'\n' read -r -a REPO_DIRS -d $'\c0' <"$GITALL_CONF_FILE"
  echo::info"${#REPO_DIRS[*]} directory found in $GITALL_CONF_FILE"
fi


# The root directory where all repository may be the children
GITALL_CODE_HOME=${GITALL_CODE_HOME:-$HOME/code}
for childPath in "$GITALL_CODE_HOME"/*; do
  if [ -d "$childPath" ]; then
    REPO_DIRS+=("$childPath")
  fi
done

if [ ${#REPO_DIRS[*]} == 0 ]; then
  echo::err'No Git repository found'
  exit 1
fi

COMMAND=${1:-}


if [ "$COMMAND" == "" ]; then
  echo 'No command was given, status chosen.'
  COMMAND=status
fi
CLI_NAME=$(basename "$0")
echo
echo "${CLI_NAME^} ${COMMAND^}"
echo "-------------------------------------------"
echo ""
case ${COMMAND} in
status)
  COMMAND_STRING="gitStatus"
  ;;
autopull)
  COMMAND_STRING="gitAutoPull"
  ;;
statusg)
  COMMAND_STRING="git status"
  ;;
autopush)
  COMMAND_STRING="gitAutoPush"
  ;;
commit)
  COMMAND_STRING="git commit"
  ;;
restart)
  COMMAND_STRING="gitResetAndClean"
  ;;
sync)
  COMMAND_STRING="sync"
  ;;
*)
  COMMAND_STRING="git ${COMMAND}"
  ;;
esac

for REPO_DIR in "${REPO_DIRS[@]}"; do
  pushd "$REPO_DIR" >/dev/null || checkStatus
  PWD=$(pwd)
  FQDN=${PWD##*/} # the directory name is the FQDN
  echo "* ${FQDN^} ($PWD)"
  CURRENT_BRANCH=$(git symbolic-ref HEAD --short)
  echo "  * Branch: $CURRENT_BRANCH"
  CURRENT_BRANCH_UPSTREAM=$(git rev-parse --abbrev-ref "@{u}")
  echo "  * Upstream: $CURRENT_BRANCH_UPSTREAM"
  if ! (eval "${COMMAND_STRING}" "$@"); then
    echo::err"The command ${COMMAND_STRING} has error"
  fi
  echo ""
  popd >/dev/null || checkStatus
done

if [[ ${COMMAND} == 'status' ]]; then
  # As stated: https://git-scm.com/docs/git-ls-files#Documentation/git-ls-files.txt--t
  cat <<EOF
--------------------------------------------------------------
Legend File Status:
A - untracked new file (staged, in next commit)
H - tracked file that is not either unmerged or skip-worktree
S - tracked file that is skip-worktree
M - tracked file that is unmerged (may be or not staged, ie in the next commit)
R - tracked file with unstaged removal/deletion
C - tracked file with unstaged modification/change
K - untracked paths which are part of file/directory conflicts which prevent checking out tracked files
? - untracked file
U - file with resolve-undo information
EOF
fi

